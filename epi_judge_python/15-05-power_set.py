from typing import List

from test_framework import generic_test, test_utils

"""
Leetcode: 78. Subsets https://leetcode.com/problems/subsets/
Write a function that takes as input a set and returns its powerset
A set can have 2^n subsets. Set of all subsets is called a Power set, including null
{a,b,c} will have 2^3 subsets = 8 powersets

A recursive algorithm is used to generate the power set P(S) of any finite set S.
https://byjus.com/maths/power-set/#:~:text=In%20set%20theory%2C%20the%20power,set%2C%20of%20a%20given%20set.
The operation F (e, T) is defined as:
F (e, T) = { X U {e} | X âˆˆ T }
This returns each of the set X in T that has the element x.
If Set S = { }, then P(S) = { { } } is returned.
If not, the following algorithm is followed.
If e is an element in Set S, T = S {e} such that S { e } forms the relative complement of the element e in set S, the power set is generated by the following algorithm:
P(S) = P(T) U F ( e, P(T))
To conclude, if the set S is empty, then the only element in the power set will be the null set. If not, the power set will become the union of all the subsets containing the particular element and the subsets not containing the particular element.
Logic:
Example [0, 1, 2]
    First recursion method goes onto individual elements, and second recursion method goes on to joining
    Remember: unlike in permutation where we have to try combinations, here the order is important, if 1 comes before 2, we 
    cant join both as [2,1], we have to join them as [1, 2]
    So trick is to separate out to the last element and join (union) them in the second recursion
    Below is the order of output
    [[], [2], [1], [1,2], [0], [0,2], [0,1], [0,1,2]]
To simplify, always start from a small example lets says just [1], or [0, 1]
"""
def generate_power_set_ori(input_set: List[int]) -> List[List[int]]:

    # Generate all subsets whose intersection with input_set[0], ...,
    # input_set[to_be_selected - 1] is exactly selected_so_far.
    def directed_power_set(to_be_selected, selected_so_far):
        if to_be_selected == len(input_set):
            power_set.append(selected_so_far) #O(n) here
            return

        directed_power_set(to_be_selected + 1, selected_so_far)
        # Generate all subsets that contain input_set[to_be_selected].
        directed_power_set(to_be_selected + 1,
                           selected_so_far + [input_set[to_be_selected]]) #union here

    power_set: List[List[int]] = []
    directed_power_set(0, [])
    return power_set

#my take based on leetcode, but using loop
"""
    Logic:
        Doesnt use recursion
        You pull one element from the given set, and start combining that with each element in the result and then 
        adding back to result. Now move to second element and do again.
        Basically you keep combining the new elements and add back to result
        Source: https://leetcode.com/problems/subsets/Figures/78/recursion.png
        Pythonic solution is based on that
    Time complexity: O(2^N) to generate all subsets and then O(N) for copy each of them into output list, hence O(N2^N)
    Space:  O(N x 2^N), temp below keep each subset hence N x 2^N
"""
def generate_power_set_loop(input_set: List[int]) -> List[List[int]]:
    result = [[]]
    for i in input_set:
        temp = []
        for subset in result:
            temp.append(subset + [i])
        # result.extend(temp) #(or use extend)
        result = result + temp #(or use extend) #O(n) here 
    return result



generate_power_set_loop([0, 1, 2])



#second approach leetcode, recursion-backtracking
# https://leetcode.com/problems/subsets/Figures/78/combinations.png
# https://leetcode.com/problems/subsets/Figures/78/backtracking.png
"""
Solution X123
Most intuitive solution using backtracking
Logic:
    1 - Since length of each subset will vary from 0 to n, we try to generate every subset which honor these length
    2 - To generate each subset for a specific length, we use recursion-backtracking
Same Time and Space complexities
"""
#modified from leetcode
#use this url to understand the code https://leetcode.com/problems/subsets-ii/Figures/90/90_approach3_1.png
#every node is an answer, so after creating that node, insert it into the result array
def generate_power_set_another_recursion(input_set: List[int]) -> List[List[int]]:
    def backtrack(start = 0, curr = []): #this is important
        # if the combination is done
        # if len(curr) == k:  
        output.append(curr[:]) #O(n) here
            # return
        for i in range(start, n):
            # add nums[i] into the current combination
            curr.append(input_set[i])
            # use next integers to complete the combination
            backtrack(i + 1, curr)
            # backtrack
            curr.pop()
    
    output = []
    n = len(input_set)
    # for k in range(n + 1):
    backtrack(0, [])
    return output

generate_power_set_another_recursion([1,2,3])

#backtrack without any base case
def subsets(nums: List[int]) -> List[List[int]]:
    def backtrack(start = 0, curr = []): #this is important
        output.append(curr[:]) #O(n) here
        for i in range(start, n):
            # add nums[i] into the current combination
            curr.append(nums[i])
            # use next integers to complete the combination
            backtrack(i + 1, curr)
            # backtrack
            curr.pop()
    
    output = []
    nums.sort() #important
    n = len(nums)
    # for k in range(n + 1):
    backtrack(0, [])
    return output

"""
The idea of this solution is originated from Donald E. Knuth.
Third approach, using binary, non recursive approach
The idea is that we map each subset to a bitmask of length n, where 1 on the ith position in bitmask means the presence of nums[i] in the subset, and 0 means its absence. https://leetcode.com/problems/subsets/Figures/78/bitmask4.png
For instance, the bitmask 0..00 (all zeros) corresponds to an empty subset, and the bitmask 1..11 (all ones) corresponds to the entire input array.
Same Time and Space complexities
So, how to generate binaries, simple either create a binary function or use bin function. Since there are 2^n subsets
for n= 3, it will be 8. so generate binaries for 0, 1, 2, 3...., 7
Step:
    Generate all possible binary bitmasks of length n.
    Map a subset to each bitmask: 1 on the ith position in bitmask means the presence of nums[i] in the subset, and 0 means its absence.
    Return output list.
    Use x & (x-1) and x & ~(x - 1) to isolate the position of each bit in the binary number, and then use it as a index
Time complexity: O(N x 2^N) to generate all subsets and then copy them into output list.
Space:  O(N x 2^N), overall time is really fast in practice
"""
import math
def generate_power_set(input_set: List[int]) -> List[List[int]]:
    power_set = []
    for int_for_subset in range(1 << len(input_set)):#same as 2^n
        bit_array = int_for_subset
        subset = []

        while bit_array:#faster than the one in leetcode
            subset.append(input_set[int(math.log2(bit_array & ~(bit_array - 1)))])#getting the index in terms of power where that 1 is location 
            bit_array &= (bit_array - 1) #removes lsb bit one by one
        power_set.append(subset) #O(n) here
    return power_set

#another
def generate_power_set2(nums: List[int]) -> List[List[int]]:
    n = len(nums)
    output = []
    
    for i in range(2**n, 2**(n + 1)):
        # generate bitmask, from 0..00 to 1..11
        bitmask = bin(i)[3:]#return value is string
        
        # append subset corresponding to that bitmask
        output.append([nums[j] for j in range(n) if bitmask[j] == '1'])
    
    return output

#variant 1
"""
Leetcode 90. Subsets II
https://leetcode.com/problems/subsets-ii/
Solve the Power subset problem where duplicates may be present
key is sorting the array, and checking the presence of subset before adding
"""
def generate_power_set_dups(input_set: List[int]) -> List[List[int]]:
    power_set = set()
    input_set.sort() #important
    for int_for_subset in range(1 << len(input_set)):#same as 2^n
        bit_array = int_for_subset
        subset = []

        while bit_array:#faster than the one in leetcode
            subset.append(input_set[int(math.log2(bit_array & ~(bit_array - 1)))])
            bit_array &= (bit_array - 1) #removes lsb bit one by one
        subset = tuple(subset)#only tuple can be added into set/hash
        # if subset not in power_set:
        power_set.add(subset) #O(n) here
    return power_set

generate_power_set_dups([2, 2, 3, 0])
#another solution
def generate_power_set_dups(input_set: List[int]) -> List[List[int]]:
    def backtrack(start = 0, curr = []): #this is important
        # if the combination is done
        # if len(curr) == k:  
        output.add(tuple(curr[:])) #O(n) here
            # return
        for i in range(start, n):
            # add nums[i] into the current combination
            curr.append(input_set[i])
            # use next integers to complete the combination
            backtrack(i + 1, curr)
            # backtrack
            curr.pop()

    output = set()
    input_set.sort() #important
    n = len(input_set)
    # for k in range(n + 1):
    backtrack(0, [])
    return output
#another, slightly modified version of above
def generate_power_set_dups(input_set: List[int]) -> List[List[int]]:
    def backtrack(start = 0, curr = []): #this is important
        # if the combination is done
        # if len(curr) == k:  
        output.append(curr[:]) #O(n) here
            # return
        for i in range(start, n):
            # add nums[i] into the current combination
            if i > start and input_set[i] == input_set[i-1]:
                continue
            curr.append(input_set[i])
            # use next integers to complete the combination
            backtrack(i + 1, curr)
            # backtrack
            curr.pop()

    output = []
    input_set.sort() #important
    n = len(input_set)
    # for k in range(n + 1):
    backtrack(0, [])
    return output



# Pythonic solution
def generate_power_set_pythonic(S):
    power_set = [[]]
    for a in S:
        power_set += [s + [a] for s in power_set]
    return power_set



if __name__ == '__main__':
    exit(
        generic_test.generic_test_main('15-05-power_set.py', 'power_set.tsv',
                                       generate_power_set,
                                       test_utils.unordered_compare))
